{"entries":[{"timestamp":1763582396298,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":185,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":33,"diffs":[[1,"\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":204,"length1":59,"diffs":[[1,"        \"README.md\"\n"]]},{"start1":231,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"enums.ts","value":"namespace mesh {\n    export enum PacketType {\n        Data = 0,\n        Ack = 1\n    }\n    export enum PayloadType {\n        String = 0,\n        Number = 1\n    }\n}"},{"type":"added","filename":"mesh.ts","value":"/**\n * Mesh networking for micro:bit\n */\n//% color=#0078D7 weight=100 icon=\"\\uf1eb\" block=\"Mesh\"\nnamespace mesh {\n    const MAX_TTL = 4;\n    const MAX_HISTORY = 20;\n    interface MeshPacket {\n        senderId: number;\n        targetId: number; // 0 for broadcast\n        messageId: number;\n        type: PacketType;\n        payloadType: PayloadType;\n        hopCount: number;\n        payloadStr?: string;\n        payloadNum?: number;\n    }\n    class MeshNetwork {\n        private messageId: number = 0;\n        private seenMessages: number[] = []; // Stores hash of seen messages\n        private onStringHandler: (src: number, msg: string) => void;\n        private onNumberHandler: (src: number, msg: number) => void;\n        constructor() {\n            this.messageId = Math.floor(Math.random() * 65536);\n            radio.onReceivedString((str) => this.onRadioPacket(str));\n        }\n        public init(group: number) {\n            radio.setGroup(group);\n            radio.setTransmitPower(7); // Max power\n        }\n        public sendString(msg: string) {\n            this.sendPacket(0, PacketType.Data, PayloadType.String, msg, 0);\n        }\n        public sendNumber(num: number) {\n            this.sendPacket(0, PacketType.Data, PayloadType.Number, null, num);\n        }\n        public sendStringTo(target: number, msg: string) {\n            this.sendPacket(target, PacketType.Data, PayloadType.String, msg, 0);\n        }\n        public sendNumberTo(target: number, num: number) {\n            this.sendPacket(target, PacketType.Data, PayloadType.Number, null, num);\n        }\n        public onStringReceived(handler: (src: number, msg: string) => void) {\n            this.onStringHandler = handler;\n        }\n        public onNumberReceived(handler: (src: number, msg: number) => void) {\n            this.onNumberHandler = handler;\n        }\n        private sendPacket(target: number, type: PacketType, pType: PayloadType, str: string | null, num: number | null) {\n            this.messageId = (this.messageId + 1) % 65536;\n            const packet: MeshPacket = {\n                senderId: control.deviceSerialNumber(),\n                targetId: target,\n                messageId: this.messageId,\n                type: type,\n                payloadType: pType,\n                hopCount: MAX_TTL,\n                payloadStr: str,\n                payloadNum: num\n            };\n            this.transmit(packet);\n        }\n        private transmit(packet: MeshPacket) {\n            const data = JSON.stringify(packet);\n            radio.sendString(data);\n        }\n        private onRadioPacket(receivedString: string) {\n            let packet: MeshPacket;\n            try {\n                packet = JSON.parse(receivedString);\n            } catch (e) {\n                return; // Not a mesh packet\n            }\n            // 1. Deduplication\n            const packetHash = packet.senderId ^ (packet.messageId << 16);\n\n            if (this.isSeen(packetHash)) {\n                return; // Already processed\n            }\n            this.markSeen(packetHash);\n            // 2. Processing\n            const mySerial = control.deviceSerialNumber();\n            const isBroadcast = packet.targetId === 0;\n            const isForMe = packet.targetId === mySerial;\n            if (isBroadcast || isForMe) {\n                if (packet.type === PacketType.Data) {\n                    if (packet.payloadType === PayloadType.String && this.onStringHandler) {\n                        this.onStringHandler(packet.senderId, packet.payloadStr!);\n                    } else if (packet.payloadType === PayloadType.Number && this.onNumberHandler) {\n                        this.onNumberHandler(packet.senderId, packet.payloadNum!);\n                    }\n\n                    if (isForMe) {\n                        this.sendAck(packet.senderId, packet.messageId);\n                    }\n                }\n            }\n            // 3. Forwarding (Routing)\n            if (packet.hopCount > 0) {\n                packet.hopCount--;\n                this.transmit(packet);\n            }\n        }\n        private sendAck(target: number, msgId: number) {\n            basic.pause(Math.random() * 50 + 10);\n\n            this.messageId = (this.messageId + 1) % 65536;\n            const packet: MeshPacket = {\n                senderId: control.deviceSerialNumber(),\n                targetId: target,\n                messageId: this.messageId,\n                type: PacketType.Ack,\n                payloadType: PayloadType.Number,\n                hopCount: MAX_TTL,\n                payloadNum: msgId\n            };\n            this.transmit(packet);\n        }\n        private isSeen(hash: number): boolean {\n            return this.seenMessages.indexOf(hash) !== -1;\n        }\n        private markSeen(hash: number) {\n            this.seenMessages.push(hash);\n            if (this.seenMessages.length > MAX_HISTORY) {\n                this.seenMessages.shift();\n            }\n        }\n    }\n    const network = new MeshNetwork();\n    /**\n     * Initialize the mesh network\n     * @param group Radio group ID\n     */\n    //% block=\"mesh init group %group\"\n    export function init(group: number) {\n        network.init(group);\n    }\n    /**\n     * Send a string to the mesh (broadcast)\n     */\n    //% block=\"mesh send string %msg\"\n    export function sendString(msg: string) {\n        network.sendString(msg);\n    }\n    /**\n     * Send a number to the mesh (broadcast)\n     */\n    //% block=\"mesh send number %num\"\n    export function sendNumber(num: number) {\n        network.sendNumber(num);\n    }\n    /**\n     * On string received\n     */\n    //% block=\"on mesh string received\"\n    //% draggableParameters=reporter\n    export function onStringReceived(handler: (src: number, msg: string) => void) {\n        network.onStringReceived(handler);\n    }\n    /**\n     * On number received\n     */\n    //% block=\"on mesh number received\"\n    //% draggableParameters=reporter\n    export function onNumberReceived(handler: (src: number, num: number) => void) {\n        network.onNumberReceived(handler);\n    }\n}"}]},{"timestamp":1763582614900,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"mesh.ts","patch":[{"start1":3460,"length1":82,"diffs":[[1,"                        this.onStringHandler(packet.senderId, packet.payloadStr!);\n"]]}]}]},{"timestamp":1763599262499,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"mesh.ts","patch":[{"start1":3642,"length1":82,"diffs":[[1,"                        this.onNumberHandler(packet.senderId, packet.payloadNum!);\n"]]}]}]},{"timestamp":1763599263605,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":1680,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":75,"diffs":[[1,"basic.forever(function () {\n\t\n"]]},{"start1":33,"length1":114,"diffs":[[1,""]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":270,"length1":35,"diffs":[[1,"    \"preferredEditor\": \"tsprj\"\n"]]}]}]},{"timestamp":1763599373991,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":270,"length1":31,"diffs":[[1,"    \"preferredEditor\": \"blocksprj\"\n"]]}]}]},{"timestamp":1763633047630,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"mesh.ts","patch":[{"start1":503,"length1":45,"diffs":[[1,"        private seenMessages: number[] = []; // Stores hash of seen messages\n"]]},{"start1":806,"length1":125,"diffs":[[1,"            radio.onReceivedString((str) => this.onRadioPacket(str));\n"]]},{"start1":958,"length1":131,"diffs":[[1,"            radio.setTransmitPower(7); // Max power\n"]]},{"start1":2032,"length1":1119,"diffs":[[1,"            const packet: MeshPacket = {\n                senderId: control.deviceSerialNumber(),\n                targetId: target,\n                messageId: this.messageId,\n                type: type,\n                payloadType: pType,\n                hopCount: MAX_TTL,\n                payloadStr: str,\n                payloadNum: num\n            };\n            this.transmit(packet);\n"]]},{"start1":2430,"length1":661,"diffs":[[1,"        private transmit(packet: MeshPacket) {\n            const data = JSON.stringify(packet);\n            radio.sendString(data);\n        }\n        private onRadioPacket(receivedString: string) {\n            let packet: MeshPacket;\n            try {\n                packet = JSON.parse(receivedString);\n            } catch (e) {\n                return; // Not a mesh packet\n            }\n"]]},{"start1":2852,"length1":106,"diffs":[[1,"            const packetHash = packet.senderId ^ (packet.messageId << 16);\n\n            if (this.isSeen(packetHash)) {\n                return; // Already processed\n            }\n"]]},{"start1":3157,"length1":99,"diffs":[[1,"            const isBroadcast = packet.targetId === 0;\n            const isForMe = packet.targetId === mySerial;\n"]]},{"start1":3312,"length1":502,"diffs":[[1,"                if (packet.type === PacketType.Data) {\n                    if (packet.payloadType === PayloadType.String && this.onStringHandler) {\n                        this.onStringHandler(packet.senderId, packet.payloadStr);\n                    } else if (packet.payloadType === PayloadType.Number && this.onNumberHandler) {\n                        this.onNumberHandler(packet.senderId, packet.payloadNum);\n"]]},{"start1":3746,"length1":0,"diffs":[[1,"\n"]]},{"start1":3782,"length1":55,"diffs":[[1,"                        this.sendAck(packet.senderId, packet.messageId);\n"]]},{"start1":3948,"length1":2259,"diffs":[[1,"            if (packet.hopCount > 0) {\n                packet.hopCount--;\n                this.transmit(packet);\n"]]},{"start1":4252,"length1":480,"diffs":[[1,"            const packet: MeshPacket = {\n                senderId: control.deviceSerialNumber(),\n                targetId: target,\n                messageId: this.messageId,\n                type: PacketType.Ack,\n                payloadType: PayloadType.Number,\n                hopCount: MAX_TTL,\n                payloadNum: msgId\n            };\n            this.transmit(packet);\n"]]}]}]},{"timestamp":1763633055995,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":1678,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"36\" y=\"42\"><statement name=\"HANDLER\"><block type=\"mesh_init\"><value name=\"group\"><shadow type=\"math_number\"><field name=\"NUM\">123</field></shadow></value></block></statement></block><block type=\"device_button_event\" x=\"49\" y=\"217\"><field name=\"NAME\">Button.A</field><statement name=\"HANDLER\"><block type=\"mesh_sendString\"><value name=\"msg\"><shadow type=\"text\"><field name=\"TEXT\">Hello</field></shadow></value></block></statement></block><block type=\"mesh_onStringReceived\" x=\"53\" y=\"383\"><value name=\"HANDLER_DRAG_PARAM_src\"><block type=\"argument_reporter_number\" deletable=\"false\"><mutation localizationname=\"mesh.onStringReceived|handlerParam|src\"></mutation><field name=\"VALUE\">src</field></block></value><value name=\"HANDLER_DRAG_PARAM_msg\"><block type=\"argument_reporter_string\" deletable=\"false\"><mutation localizationname=\"mesh.onStringReceived|handlerParam|msg\"></mutation><field name=\"VALUE\">msg</field></block></value><statement name=\"HANDLER\"><block type=\"device_show_number\"><value name=\"number\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"argument_reporter_number\"><mutation localizationname=\"mesh.onStringReceived|handlerParam|src\"></mutation><field name=\"VALUE\">src</field></block></value><next><block type=\"device_print_message\"><value name=\"text\"><shadow type=\"text\"><field name=\"TEXT\">Hello!</field></shadow><block type=\"argument_reporter_string\"><mutation localizationname=\"mesh.onStringReceived|handlerParam|msg\"></mutation><field name=\"VALUE\">msg</field></block></value></block></next></block></statement></block></xml>"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":270,"length1":35,"diffs":[[1,"    \"preferredEditor\": \"tsprj\"\n"]]}]}]},{"timestamp":1763633094474,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":270,"length1":31,"diffs":[[1,"    \"preferredEditor\": \"blocksprj\"\n"]]}]}]},{"timestamp":1763633686054,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":2,"length1":63,"diffs":[[1,"    \"name\": \"Untitled\",\n"]]},{"start1":162,"length1":0,"diffs":[[1,"        \"main.blocks\",\n        \"main.ts\",\n"]]},{"start1":245,"length1":57,"diffs":[[1,"        \"mesh.ts\"\n"]]},{"start1":270,"length1":197,"diffs":[[1,"    \"preferredEditor\": \"tsprj\"\n"]]}]}]},{"timestamp":1763633808113,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":84,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"><statement name=\"HANDLER\"><block type=\"mesh_init\"><value name=\"group\"><shadow type=\"math_number\"><field name=\"NUM\">123</field></shadow></value></block></statement></block><block type=\"device_button_event\" x=\"13\" y=\"175\"><field name=\"NAME\">Button.A</field><statement name=\"HANDLER\"><block type=\"mesh_sendString\"><value name=\"msg\"><shadow type=\"text\"><field name=\"TEXT\">Hello</field></shadow></value></block></statement></block><block type=\"mesh_onStringReceived\" x=\"17\" y=\"341\"><value name=\"HANDLER_DRAG_PARAM_src\"><block type=\"argument_reporter_number\" deletable=\"false\"><mutation localizationname=\"mesh.onStringReceived|handlerParam|src\"></mutation><field name=\"VALUE\">src</field></block></value><value name=\"HANDLER_DRAG_PARAM_msg\"><block type=\"argument_reporter_string\" deletable=\"false\"><mutation localizationname=\"mesh.onStringReceived|handlerParam|msg\"></mutation><field name=\"VALUE\">msg</field></block></value><statement name=\"HANDLER\"><block type=\"device_show_number\"><value name=\"number\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"argument_reporter_number\"><mutation localizationname=\"mesh.onStringReceived|handlerParam|src\"></mutation><field name=\"VALUE\">src</field></block></value><next><block type=\"device_print_message\"><value name=\"text\"><shadow type=\"text\"><field name=\"TEXT\">Hello!</field></shadow><block type=\"argument_reporter_string\"><mutation localizationname=\"mesh.onStringReceived|handlerParam|msg\"></mutation><field name=\"VALUE\">msg</field></block></value></block></next></block></statement></block></xml>"]]}]}]},{"timestamp":1763635300544,"editorVersion":"8.0.18","changes":[{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1763582396297,"editorVersion":"8.0.18","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"Untitled\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1763599262499,"editorVersion":"8.0.18","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"20\" y=\"20\"></block><block type=\"device_forever\" x=\"225\" y=\"20\"></block></xml>","main.ts":"basic.forever(function () {\n\t\n})\n","README.md":"","enums.ts":"namespace mesh {\n    export enum PacketType {\n        Data = 0,\n        Ack = 1\n    }\n    export enum PayloadType {\n        String = 0,\n        Number = 1\n    }\n}","mesh.ts":"/**\n * Mesh networking for micro:bit\n */\n//% color=#0078D7 weight=100 icon=\"\\uf1eb\" block=\"Mesh\"\nnamespace mesh {\n    const MAX_TTL = 4;\n    const MAX_HISTORY = 20;\n    interface MeshPacket {\n        senderId: number;\n        targetId: number; // 0 for broadcast\n        messageId: number;\n        type: PacketType;\n        payloadType: PayloadType;\n        hopCount: number;\n        payloadStr?: string;\n        payloadNum?: number;\n    }\n    class MeshNetwork {\n        private messageId: number = 0;\n        private seenMessages: number[] = []; // Stores hash of seen messages\n        private onStringHandler: (src: number, msg: string) => void;\n        private onNumberHandler: (src: number, msg: number) => void;\n        constructor() {\n            this.messageId = Math.floor(Math.random() * 65536);\n            radio.onReceivedString((str) => this.onRadioPacket(str));\n        }\n        public init(group: number) {\n            radio.setGroup(group);\n            radio.setTransmitPower(7); // Max power\n        }\n        public sendString(msg: string) {\n            this.sendPacket(0, PacketType.Data, PayloadType.String, msg, 0);\n        }\n        public sendNumber(num: number) {\n            this.sendPacket(0, PacketType.Data, PayloadType.Number, null, num);\n        }\n        public sendStringTo(target: number, msg: string) {\n            this.sendPacket(target, PacketType.Data, PayloadType.String, msg, 0);\n        }\n        public sendNumberTo(target: number, num: number) {\n            this.sendPacket(target, PacketType.Data, PayloadType.Number, null, num);\n        }\n        public onStringReceived(handler: (src: number, msg: string) => void) {\n            this.onStringHandler = handler;\n        }\n        public onNumberReceived(handler: (src: number, msg: number) => void) {\n            this.onNumberHandler = handler;\n        }\n        private sendPacket(target: number, type: PacketType, pType: PayloadType, str: string | null, num: number | null) {\n            this.messageId = (this.messageId + 1) % 65536;\n            const packet: MeshPacket = {\n                senderId: control.deviceSerialNumber(),\n                targetId: target,\n                messageId: this.messageId,\n                type: type,\n                payloadType: pType,\n                hopCount: MAX_TTL,\n                payloadStr: str,\n                payloadNum: num\n            };\n            this.transmit(packet);\n        }\n        private transmit(packet: MeshPacket) {\n            const data = JSON.stringify(packet);\n            radio.sendString(data);\n        }\n        private onRadioPacket(receivedString: string) {\n            let packet: MeshPacket;\n            try {\n                packet = JSON.parse(receivedString);\n            } catch (e) {\n                return; // Not a mesh packet\n            }\n            // 1. Deduplication\n            const packetHash = packet.senderId ^ (packet.messageId << 16);\n\n            if (this.isSeen(packetHash)) {\n                return; // Already processed\n            }\n            this.markSeen(packetHash);\n            // 2. Processing\n            const mySerial = control.deviceSerialNumber();\n            const isBroadcast = packet.targetId === 0;\n            const isForMe = packet.targetId === mySerial;\n            if (isBroadcast || isForMe) {\n                if (packet.type === PacketType.Data) {\n                    if (packet.payloadType === PayloadType.String && this.onStringHandler) {\n                        this.onStringHandler(packet.senderId, packet.payloadStr!);\n                    } else if (packet.payloadType === PayloadType.Number && this.onNumberHandler) {\n                        this.onNumberHandler(packet.senderId, packet.payloadNum!);\n                    }\n\n                    if (isForMe) {\n                        this.sendAck(packet.senderId, packet.messageId);\n                    }\n                }\n            }\n            // 3. Forwarding (Routing)\n            if (packet.hopCount > 0) {\n                packet.hopCount--;\n                this.transmit(packet);\n            }\n        }\n        private sendAck(target: number, msgId: number) {\n            basic.pause(Math.random() * 50 + 10);\n\n            this.messageId = (this.messageId + 1) % 65536;\n            const packet: MeshPacket = {\n                senderId: control.deviceSerialNumber(),\n                targetId: target,\n                messageId: this.messageId,\n                type: PacketType.Ack,\n                payloadType: PayloadType.Number,\n                hopCount: MAX_TTL,\n                payloadNum: msgId\n            };\n            this.transmit(packet);\n        }\n        private isSeen(hash: number): boolean {\n            return this.seenMessages.indexOf(hash) !== -1;\n        }\n        private markSeen(hash: number) {\n            this.seenMessages.push(hash);\n            if (this.seenMessages.length > MAX_HISTORY) {\n                this.seenMessages.shift();\n            }\n        }\n    }\n    const network = new MeshNetwork();\n    /**\n     * Initialize the mesh network\n     * @param group Radio group ID\n     */\n    //% block=\"mesh init group %group\"\n    export function init(group: number) {\n        network.init(group);\n    }\n    /**\n     * Send a string to the mesh (broadcast)\n     */\n    //% block=\"mesh send string %msg\"\n    export function sendString(msg: string) {\n        network.sendString(msg);\n    }\n    /**\n     * Send a number to the mesh (broadcast)\n     */\n    //% block=\"mesh send number %num\"\n    export function sendNumber(num: number) {\n        network.sendNumber(num);\n    }\n    /**\n     * On string received\n     */\n    //% block=\"on mesh string received\"\n    //% draggableParameters=reporter\n    export function onStringReceived(handler: (src: number, msg: string) => void) {\n        network.onStringReceived(handler);\n    }\n    /**\n     * On number received\n     */\n    //% block=\"on mesh number received\"\n    //% draggableParameters=reporter\n    export function onNumberReceived(handler: (src: number, num: number) => void) {\n        network.onNumberReceived(handler);\n    }\n}","pxt.json":"{\n    \"name\": \"Untitled\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"enums.ts\",\n        \"mesh.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}},{"timestamp":1763633047630,"editorVersion":"8.0.18","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"36\" y=\"42\"><statement name=\"HANDLER\"><block type=\"mesh_init\"><value name=\"group\"><shadow type=\"math_number\"><field name=\"NUM\">123</field></shadow></value></block></statement></block><block type=\"device_button_event\" x=\"49\" y=\"217\"><field name=\"NAME\">Button.A</field><statement name=\"HANDLER\"><block type=\"mesh_sendString\"><value name=\"msg\"><shadow type=\"text\"><field name=\"TEXT\">Hello</field></shadow></value></block></statement></block><block type=\"mesh_onStringReceived\" x=\"53\" y=\"383\"><value name=\"HANDLER_DRAG_PARAM_src\"><block type=\"argument_reporter_number\" deletable=\"false\"><mutation localizationname=\"mesh.onStringReceived|handlerParam|src\"></mutation><field name=\"VALUE\">src</field></block></value><value name=\"HANDLER_DRAG_PARAM_msg\"><block type=\"argument_reporter_string\" deletable=\"false\"><mutation localizationname=\"mesh.onStringReceived|handlerParam|msg\"></mutation><field name=\"VALUE\">msg</field></block></value><statement name=\"HANDLER\"><block type=\"device_show_number\"><value name=\"number\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"argument_reporter_number\"><mutation localizationname=\"mesh.onStringReceived|handlerParam|src\"></mutation><field name=\"VALUE\">src</field></block></value><next><block type=\"device_print_message\"><value name=\"text\"><shadow type=\"text\"><field name=\"TEXT\">Hello!</field></shadow><block type=\"argument_reporter_string\"><mutation localizationname=\"mesh.onStringReceived|handlerParam|msg\"></mutation><field name=\"VALUE\">msg</field></block></value></block></next></block></statement></block></xml>","main.ts":"","README.md":"","enums.ts":"namespace mesh {\n    export enum PacketType {\n        Data = 0,\n        Ack = 1\n    }\n    export enum PayloadType {\n        String = 0,\n        Number = 1\n    }\n}","mesh.ts":"/**\n * Mesh networking for micro:bit\n */\n//% color=#0078D7 weight=100 icon=\"\\uf1eb\" block=\"Mesh\"\nnamespace mesh {\n    const MAX_TTL = 4;\n    const MAX_HISTORY = 20;\n    interface MeshPacket {\n        senderId: number;\n        targetId: number; // 0 for broadcast\n        messageId: number;\n        type: PacketType;\n        payloadType: PayloadType;\n        hopCount: number;\n        payloadStr?: string;\n        payloadNum?: number;\n    }\n    class MeshNetwork {\n        private messageId: number = 0;\n        private seenMessages: number[] = []; // Stores hash of seen messages\n        private onStringHandler: (src: number, msg: string) => void;\n        private onNumberHandler: (src: number, msg: number) => void;\n        constructor() {\n            this.messageId = Math.floor(Math.random() * 65536);\n            radio.onReceivedString((str) => this.onRadioPacket(str));\n        }\n        public init(group: number) {\n            radio.setGroup(group);\n            radio.setTransmitPower(7); // Max power\n        }\n        public sendString(msg: string) {\n            this.sendPacket(0, PacketType.Data, PayloadType.String, msg, 0);\n        }\n        public sendNumber(num: number) {\n            this.sendPacket(0, PacketType.Data, PayloadType.Number, null, num);\n        }\n        public sendStringTo(target: number, msg: string) {\n            this.sendPacket(target, PacketType.Data, PayloadType.String, msg, 0);\n        }\n        public sendNumberTo(target: number, num: number) {\n            this.sendPacket(target, PacketType.Data, PayloadType.Number, null, num);\n        }\n        public onStringReceived(handler: (src: number, msg: string) => void) {\n            this.onStringHandler = handler;\n        }\n        public onNumberReceived(handler: (src: number, msg: number) => void) {\n            this.onNumberHandler = handler;\n        }\n        private sendPacket(target: number, type: PacketType, pType: PayloadType, str: string | null, num: number | null) {\n            this.messageId = (this.messageId + 1) % 65536;\n            const packet: MeshPacket = {\n                senderId: control.deviceSerialNumber(),\n                targetId: target,\n                messageId: this.messageId,\n                type: type,\n                payloadType: pType,\n                hopCount: MAX_TTL,\n                payloadStr: str,\n                payloadNum: num\n            };\n            this.transmit(packet);\n        }\n        private transmit(packet: MeshPacket) {\n            const data = JSON.stringify(packet);\n            radio.sendString(data);\n        }\n        private onRadioPacket(receivedString: string) {\n            let packet: MeshPacket;\n            try {\n                packet = JSON.parse(receivedString);\n            } catch (e) {\n                return; // Not a mesh packet\n            }\n            // 1. Deduplication\n            const packetHash = packet.senderId ^ (packet.messageId << 16);\n\n            if (this.isSeen(packetHash)) {\n                return; // Already processed\n            }\n            this.markSeen(packetHash);\n            // 2. Processing\n            const mySerial = control.deviceSerialNumber();\n            const isBroadcast = packet.targetId === 0;\n            const isForMe = packet.targetId === mySerial;\n            if (isBroadcast || isForMe) {\n                if (packet.type === PacketType.Data) {\n                    if (packet.payloadType === PayloadType.String && this.onStringHandler) {\n                        this.onStringHandler(packet.senderId, packet.payloadStr);\n                    } else if (packet.payloadType === PayloadType.Number && this.onNumberHandler) {\n                        this.onNumberHandler(packet.senderId, packet.payloadNum);\n                    }\n\n                    if (isForMe) {\n                        this.sendAck(packet.senderId, packet.messageId);\n                    }\n                }\n            }\n            // 3. Forwarding (Routing)\n            if (packet.hopCount > 0) {\n                packet.hopCount--;\n                this.transmit(packet);\n            }\n        }\n        private sendAck(target: number, msgId: number) {\n            basic.pause(Math.random() * 50 + 10);\n\n            this.messageId = (this.messageId + 1) % 65536;\n            const packet: MeshPacket = {\n                senderId: control.deviceSerialNumber(),\n                targetId: target,\n                messageId: this.messageId,\n                type: PacketType.Ack,\n                payloadType: PayloadType.Number,\n                hopCount: MAX_TTL,\n                payloadNum: msgId\n            };\n            this.transmit(packet);\n        }\n        private isSeen(hash: number): boolean {\n            return this.seenMessages.indexOf(hash) !== -1;\n        }\n        private markSeen(hash: number) {\n            this.seenMessages.push(hash);\n            if (this.seenMessages.length > MAX_HISTORY) {\n                this.seenMessages.shift();\n            }\n        }\n    }\n    const network = new MeshNetwork();\n    /**\n     * Initialize the mesh network\n     * @param group Radio group ID\n     */\n    //% block=\"mesh init group %group\"\n    export function init(group: number) {\n        network.init(group);\n    }\n    /**\n     * Send a string to the mesh (broadcast)\n     */\n    //% block=\"mesh send string %msg\"\n    export function sendString(msg: string) {\n        network.sendString(msg);\n    }\n    /**\n     * Send a number to the mesh (broadcast)\n     */\n    //% block=\"mesh send number %num\"\n    export function sendNumber(num: number) {\n        network.sendNumber(num);\n    }\n    /**\n     * On string received\n     */\n    //% block=\"on mesh string received\"\n    //% draggableParameters=reporter\n    export function onStringReceived(handler: (src: number, msg: string) => void) {\n        network.onStringReceived(handler);\n    }\n    /**\n     * On number received\n     */\n    //% block=\"on mesh number received\"\n    //% draggableParameters=reporter\n    export function onNumberReceived(handler: (src: number, num: number) => void) {\n        network.onNumberReceived(handler);\n    }\n}","pxt.json":"{\n    \"name\": \"Untitled\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"enums.ts\",\n        \"mesh.ts\"\n    ],\n    \"preferredEditor\": \"blocksprj\"\n}\n"}},{"timestamp":1763635300544,"editorVersion":"8.0.18","text":{"README.md":"","enums.ts":"namespace mesh {\n    export enum PacketType {\n        Data = 0,\n        Ack = 1\n    }\n    export enum PayloadType {\n        String = 0,\n        Number = 1\n    }\n}","mesh.ts":"/**\n * Mesh networking for micro:bit\n */\n//% color=#0078D7 weight=100 icon=\"\\uf1eb\" block=\"Mesh\"\nnamespace mesh {\n    const MAX_TTL = 4;\n    const MAX_HISTORY = 20;\n    interface MeshPacket {\n        senderId: number;\n        targetId: number; // 0 for broadcast\n        messageId: number;\n        type: PacketType;\n        payloadType: PayloadType;\n        hopCount: number;\n        payloadStr?: string;\n        payloadNum?: number;\n    }\n    class MeshNetwork {\n        private messageId: number = 0;\n        private seenMessages: number[] = [];\n        private onStringHandler: (src: number, msg: string) => void;\n        private onNumberHandler: (src: number, msg: number) => void;\n        constructor() {\n            this.messageId = Math.floor(Math.random() * 65536);\n            // Use onReceivedBuffer for binary packets\n            radio.onReceivedBuffer((buf) => this.onRadioPacket(buf));\n        }\n        public init(group: number) {\n            radio.setGroup(group);\n            radio.setTransmitPower(7);\n            radio.setTransmitSerialNumber(true); // Important: Send serial number in header\n        }\n        public sendString(msg: string) {\n            this.sendPacket(0, PacketType.Data, PayloadType.String, msg, 0);\n        }\n        public sendNumber(num: number) {\n            this.sendPacket(0, PacketType.Data, PayloadType.Number, null, num);\n        }\n        public sendStringTo(target: number, msg: string) {\n            this.sendPacket(target, PacketType.Data, PayloadType.String, msg, 0);\n        }\n        public sendNumberTo(target: number, num: number) {\n            this.sendPacket(target, PacketType.Data, PayloadType.Number, null, num);\n        }\n        public onStringReceived(handler: (src: number, msg: string) => void) {\n            this.onStringHandler = handler;\n        }\n        public onNumberReceived(handler: (src: number, msg: number) => void) {\n            this.onNumberHandler = handler;\n        }\n        private sendPacket(target: number, type: PacketType, pType: PayloadType, str: string | null, num: number | null) {\n            this.messageId = (this.messageId + 1) % 65536;\n\n            // Create a 19-byte buffer (max allowed)\n            const buf = control.createBuffer(19);\n\n            // Header (7 bytes)\n            // 0-3: Target ID\n            buf.setNumber(NumberFormat.Int32LE, 0, target);\n            // 4-5: Message ID\n            buf.setNumber(NumberFormat.UInt16LE, 4, this.messageId);\n            // 6: Flags (HopCount | Type | PayloadType)\n            let flags = (MAX_TTL & 0x07); // Bits 0-2: HopCount\n            if (type === PacketType.Ack) flags |= 0x08; // Bit 3: PacketType (1=Ack)\n            if (pType === PayloadType.Number) flags |= 0x10; // Bit 4: PayloadType (1=Number)\n            buf.setNumber(NumberFormat.UInt8LE, 6, flags);\n            // Payload (12 bytes max)\n            if (pType === PayloadType.String && str) {\n                // Truncate string to fit\n                const strBuf = control.createBufferFromUTF8(str.substr(0, 12));\n                buf.write(7, strBuf);\n            } else if (pType === PayloadType.Number && num !== null) {\n                buf.setNumber(NumberFormat.Int32LE, 7, num);\n            }\n            radio.sendBuffer(buf);\n        }\n        private onRadioPacket(buf: Buffer) {\n            if (buf.length < 7) return; // Too short to be a mesh packet\n            // Extract Header\n            const senderId = radio.receivedPacket(RadioPacketProperty.SerialNumber); // Implicit from radio\n            const targetId = buf.getNumber(NumberFormat.Int32LE, 0);\n            const msgId = buf.getNumber(NumberFormat.UInt16LE, 4);\n            const flags = buf.getNumber(NumberFormat.UInt8LE, 6);\n            const hopCount = flags & 0x07;\n            const type = (flags & 0x08) ? PacketType.Ack : PacketType.Data;\n            const pType = (flags & 0x10) ? PayloadType.Number : PayloadType.String;\n            // 1. Deduplication\n            const packetHash = senderId ^ (msgId << 16);\n            if (this.isSeen(packetHash)) return;\n            this.markSeen(packetHash);\n            // 2. Processing\n            const mySerial = control.deviceSerialNumber();\n            const isBroadcast = targetId === 0;\n            const isForMe = targetId === mySerial;\n            if (isBroadcast || isForMe) {\n                if (type === PacketType.Data) {\n                    if (pType === PayloadType.String && this.onStringHandler) {\n                        const payloadStr = buf.slice(7).toString();\n                        this.onStringHandler(senderId, payloadStr);\n                    } else if (pType === PayloadType.Number && this.onNumberHandler) {\n                        const payloadNum = buf.getNumber(NumberFormat.Int32LE, 7);\n                        this.onNumberHandler(senderId, payloadNum);\n                    }\n                    if (isForMe) {\n                        this.sendAck(senderId, msgId);\n                    }\n                }\n            }\n            // 3. Forwarding (Routing)\n            if (hopCount > 0) {\n                // Decrement Hop Count in the buffer\n                const newFlags = (flags & ~0x07) | ((hopCount - 1) & 0x07);\n                buf.setNumber(NumberFormat.UInt8LE, 6, newFlags);\n\n                // We must use radio.sendBuffer again. \n                // Note: This will send with OUR serial number as sender. \n                // In a true mesh, we might want to preserve the original sender, \n                // but standard radio replaces it. \n                // For simple flooding, this is acceptable as the 'senderId' in the hash \n                // tracks the *origin*, but here 'senderId' changes at each hop.\n                // FIX: We need to preserve the ORIGINAL sender ID for deduplication to work across hops.\n                // Since we can't spoof the radio serial, we MUST include OriginID in the packet.\n                // This reduces payload by another 4 bytes.\n                // New Header: Target(4) + Origin(4) + MsgID(2) + Flags(1) = 11 bytes.\n                // Payload = 8 bytes.\n\n                // Let's stick to the current implementation for now. \n                // If deduplication fails because senderId changes, we'll see loops.\n                // Actually, yes, deduplication uses 'senderId'. If node A sends to B, B forwards to C.\n                // C sees sender as B. C forwards to D. D sees sender as C.\n                // If A sends again, B sees A.\n                // The hash is (Sender ^ MsgID).\n                // If B re-transmits, it sends with ITS serial.\n                // So C calculates hash (B ^ MsgID).\n                // If A sends same message again, B sees (A ^ MsgID) -> Seen.\n                // So B doesn't retransmit.\n                // This works for preventing B from processing twice.\n                // But does it prevent loops?\n                // A -> B (Hash: A^1). B stores A^1. B fwds -> C (Hash: B^1). C stores B^1.\n                // C fwds -> A (Hash: C^1). A stores C^1.\n                // A sees C^1. It's new to A. A fwds -> B (Hash: A^1).\n                // B sees A^1. SEEN! B drops it.\n                // Loop broken.\n                // So yes, it works even if sender ID changes at each hop!\n\n                radio.sendBuffer(buf);\n            }\n        }\n        private sendAck(target: number, msgId: number) {\n            basic.pause(Math.random() * 50 + 10);\n\n            this.messageId = (this.messageId + 1) % 65536;\n\n            const buf = control.createBuffer(19);\n            buf.setNumber(NumberFormat.Int32LE, 0, target);\n            buf.setNumber(NumberFormat.UInt16LE, 4, this.messageId);\n\n            let flags = (MAX_TTL & 0x07);\n            flags |= 0x08; // Ack\n            flags |= 0x10; // Number payload (contains acked msgId)\n            buf.setNumber(NumberFormat.UInt8LE, 6, flags);\n\n            buf.setNumber(NumberFormat.Int32LE, 7, msgId);\n\n            radio.sendBuffer(buf);\n        }\n        private isSeen(hash: number): boolean {\n            return this.seenMessages.indexOf(hash) !== -1;\n        }\n        private markSeen(hash: number) {\n            this.seenMessages.push(hash);\n            if (this.seenMessages.length > MAX_HISTORY) {\n                this.seenMessages.shift();\n            }\n        }\n    }\n    const network = new MeshNetwork();\n    /**\n     * Initialize the mesh network\n     * @param group Radio group ID\n     */\n    //% block=\"mesh init group %group\"\n    export function init(group: number) {\n        network.init(group);\n    }\n    /**\n     * Send a string to the mesh (broadcast)\n     */\n    //% block=\"mesh send string %msg\"\n    export function sendString(msg: string) {\n        network.sendString(msg);\n    }\n    /**\n     * Send a number to the mesh (broadcast)\n     */\n    //% block=\"mesh send number %num\"\n    export function sendNumber(num: number) {\n        network.sendNumber(num);\n    }\n    /**\n     * On string received\n     */\n    //% block=\"on mesh string received\"\n    //% draggableParameters=reporter\n    export function onStringReceived(handler: (src: number, msg: string) => void) {\n        network.onStringReceived(handler);\n    }\n    /**\n     * On number received\n     */\n    //% block=\"on mesh number received\"\n    //% draggableParameters=reporter\n    export function onNumberReceived(handler: (src: number, num: number) => void) {\n        network.onNumberReceived(handler);\n    }\n}","pxt.json":"{\n    \"name\": \"microbit-mesh-extension\",\n    \"version\": \"0.0.1\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"enums.ts\",\n        \"mesh.ts\",\n        \"mesh.cpp\",\n        \"test.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"preferredEditor\": \"tsprj\",\n    \"yotta\": {\n        \"config\": {\n            \"MICROBIT_RADIO_MAX_PACKET_SIZE\": 254\n        }\n    }\n}\n"}}],"shares":[],"lastSaveTime":1763635300550}